#!/bin/bash
# ============================================================================
# Script: build-efi-raw.sh
# Description: Creates a raw disk image with EFI/UEFI boot for Harvester
# ============================================================================
# This script automates the creation of a pre-installed raw disk image with
# Harvester, configured for EFI/UEFI boot instead of legacy BIOS boot.
#
# Features:
# - Automatic version detection from ISO files
# - Automatic OVMF firmware (UEFI) detection
# - QEMU VM creation with EFI boot
# - Automatic Harvester installation
# - Compression of the resulting image
#
# Prerequisites:
# - Harvester ISO already built (via 'make')
# - QEMU installed (qemu-system-x86_64)
# - OVMF installed (qemu-ovmf-x86_64 or equivalent)
# - KVM enabled and accessible
# ============================================================================

# Strict mode: stops script on first error
# Useful to avoid continuing with silent errors
set -e

# ============================================================================
# Variable Configuration
# ============================================================================
# VERSION: Harvester version (e.g., "v1.7.0")
#   - If empty: automatic detection from ISO files
#   - If set: uses this version explicitly
VERSION=""

# PROJECT_PREFIX: Prefix for generated files
# Format: "harvester-{VERSION}" (e.g., "harvester-v1.7.0")
PROJECT_PREFIX="harvester"

# ARCH: Target architecture (amd64 for x86_64)
ARCH="amd64"

# ARTIFACTS_DIR: Directory containing build artifacts
# Contains ISO, kernel, initrd generated by the main build
ARTIFACTS_DIR="dist/artifacts"

# ============================================================================
# Step 0: Automatic Version Detection
# ============================================================================
# If VERSION is not set, try to detect it automatically
# by searching for the most recent ISO file in the artifacts directory.
# This allows using the script without manually specifying the version.
# ============================================================================
if [ -z "$VERSION" ]; then
  # Search for the most recent ISO file (sorted by date, most recent first)
  # Expected format: harvester-{VERSION}-{ARCH}.iso
  # Example: harvester-v1.7.0-amd64.iso
  ISO_FILE=$(ls -t ${ARTIFACTS_DIR}/harvester-*-${ARCH}.iso 2>/dev/null | head -1)
  
  if [ -n "$ISO_FILE" ]; then
    # Extract version from filename
    # Example: "harvester-v1.7.0-amd64.iso" -> "v1.7.0"
    # Uses sed to extract the part between "harvester-" and "-${ARCH}.iso"
    VERSION=$(basename "$ISO_FILE" | sed "s/harvester-\(.*\)-${ARCH}\.iso/\1/")
    PROJECT_PREFIX="harvester-${VERSION}"
    echo "Auto-detected version: $VERSION"
  else
    echo "ERROR: Could not find ISO file in ${ARTIFACTS_DIR}/"
    echo "Please set VERSION manually or build the ISO first with 'make'"
    exit 1
  fi
else
  # If VERSION is manually set, build the prefix
  PROJECT_PREFIX="harvester-${VERSION}"
fi

echo "Building EFI raw image for: ${PROJECT_PREFIX}"

# ============================================================================
# Step 1: Locating OVMF Firmware for UEFI Boot
# ============================================================================
# OVMF (Open Virtual Machine Firmware) is required for EFI/UEFI boot.
# This firmware replaces legacy BIOS and allows VMs to boot in UEFI mode.
#
# The firmware can be found in different forms depending on the distribution:
# 1. Separate CODE/VARS files (recommended): Allows modifying NVRAM variables
#    without touching the main firmware
# 2. Combined file: All-in-one, less flexible but also works
#
# Search order (from most specific to most generic):
# - openSUSE/Fedora: /usr/share/qemu/ovmf-x86_64-{code,vars}.bin
# - Debian/Ubuntu: /usr/share/OVMF/OVMF_{CODE,VARS}.fd
# - Fallback: /usr/share/OVMF/OVMF.fd (combined file)
# ============================================================================
echo "Step 1: Locating OVMF firmware..."

# Priority search: separate files in /usr/share/qemu/ (openSUSE/Fedora)
# Format: ovmf-x86_64-code.bin and ovmf-x86_64-vars.bin
if [ -f /usr/share/qemu/ovmf-x86_64-code.bin ] && [ -f /usr/share/qemu/ovmf-x86_64-vars.bin ]; then
  OVMF_CODE="/usr/share/qemu/ovmf-x86_64-code.bin"
  OVMF_VARS="/usr/share/qemu/ovmf-x86_64-vars.bin"
  USE_SEPARATE_VARS=true  # Indicates we're using separate files
  echo "  Found: ${OVMF_CODE} and ${OVMF_VARS}"

# Alternative search: separate files in /usr/share/OVMF/ (Debian/Ubuntu)
# Format: OVMF_CODE.fd and OVMF_VARS.fd
elif [ -f /usr/share/OVMF/OVMF_CODE.fd ] && [ -f /usr/share/OVMF/OVMF_VARS.fd ]; then
  OVMF_CODE="/usr/share/OVMF/OVMF_CODE.fd"
  OVMF_VARS="/usr/share/OVMF/OVMF_VARS.fd"
  USE_SEPARATE_VARS=true
  echo "  Found: ${OVMF_CODE} and ${OVMF_VARS}"

# Fallback: combined OVMF.fd file
# If separate files are not available, use a combined file
# Note: This method is less flexible as we cannot modify NVRAM variables
# separately, but it works for basic EFI boot
elif [ -f /usr/share/OVMF/OVMF.fd ]; then
  OVMF_CODE="/usr/share/OVMF/OVMF.fd"
  USE_SEPARATE_VARS=false  # Combined file, no separate VARS
  echo "  Found: ${OVMF_CODE} (combined file)"

# Error: No OVMF firmware found
# Script cannot continue without UEFI firmware
else
  echo "ERROR: OVMF firmware not found. Please install it first:"
  echo "  Debian/Ubuntu: sudo apt-get install ovmf"
  echo "  openSUSE/SLES: sudo zypper install qemu-ovmf-x86_64"
  echo "  Fedora/RHEL:   sudo dnf install edk2-ovmf"
  exit 1
fi

# ============================================================================
# Step 2: Verifying Required Files Exist
# ============================================================================
# Before starting, verify that all required files exist:
# - ISO: Harvester ISO image containing the live system and images
# - Kernel: vmlinuz file to boot the live system
# - Initrd: Initial ramdisk containing boot modules and scripts
#
# These files are generated during ISO build (via 'make').
# ============================================================================
echo "Step 2: Verifying required files..."

# Build paths to required files
# Format: harvester-{VERSION}-{ARCH}.{ext}
ISO_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-${ARCH}.iso"
KERNEL_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-vmlinuz-${ARCH}"
INITRD_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-initrd-${ARCH}"

# Verify each file exists
# If a file is missing, stop script with explicit error message
for file in "$ISO_FILE" "$KERNEL_FILE" "$INITRD_FILE"; do
  if [ ! -f "$file" ]; then
    echo "ERROR: Required file not found: $file"
    echo "Please build the ISO first with 'make'"
    exit 1
  fi
done
echo "  All required files found"

# ============================================================================
# Step 3: Creating Raw Disk Image
# ============================================================================
# Create a 250GB raw disk image that will serve as virtual disk
# for the QEMU VM. This image will be the target disk for Harvester installation.
#
# Raw format: Unformatted format, direct access to disk sectors.
# Advantages: Simple, compatible, good performance.
# Disadvantage: Fixed size (but can be compressed afterwards).
#
# Size 250GB: Sufficient for:
# - Harvester operating system (~10GB)
# - Persistent partition (150GB configured)
# - Space for VMs and user data
# ============================================================================
echo "Step 3: Creating raw disk image..."
RAW_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-${ARCH}.raw"

# Check if image already exists
# If yes, ask for confirmation before overwriting (protection against data loss)
if [ -f "$RAW_FILE" ]; then
  read -p "Raw image already exists. Overwrite? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
  fi
  # Remove old image if confirmed
  rm -f "$RAW_FILE"
fi

# Create raw image with qemu-img
# -f raw: Raw format (unformatted)
# -o size=250G: 250GB size
# Note: File is created as "sparse file" - it only occupies space
# actually written to disk, not the full 250GB
qemu-img create -f raw -o size=250G "$RAW_FILE"
echo "  Created: $RAW_FILE"

# ============================================================================
# Step 4: Creating Temporary VARS File (if necessary)
# ============================================================================
# If using separate OVMF files (CODE/VARS), create a temporary copy
# of the VARS file because QEMU will modify it during execution
# (writing UEFI NVRAM variables).
#
# Why a temporary copy?
# - Original VARS file is often read-only or shared
# - QEMU needs to write to it to save UEFI settings
# - A temporary copy avoids modifying the original system file
#
# The EXIT trap ensures the temporary file will be removed even if
# the script is interrupted (Ctrl+C, error, etc.)
# ============================================================================
if [ "$USE_SEPARATE_VARS" = true ]; then
  # Create temporary file with mktemp
  # mktemp creates a unique file in /tmp with a random name
  TEMP_OVMF_VARS=$(mktemp)
  
  # Copy original VARS file to temporary
  cp "$OVMF_VARS" "$TEMP_OVMF_VARS"
  
  # Set permissions (644 = rw-r--r--)
  # Allows QEMU to write to the file
  chmod 644 "$TEMP_OVMF_VARS"
  
  echo "Step 4: Created temporary OVMF VARS: $TEMP_OVMF_VARS"
  
  # Configure trap to clean up temporary file on exit
  # EXIT: Triggers when script terminates (normally or with error)
  # Ensures cleanup even on interruption
  trap "rm -f $TEMP_OVMF_VARS" EXIT
fi

# ============================================================================
# Step 5: Building and Executing QEMU Command
# ============================================================================
# This step builds the complete QEMU command with all parameters
# necessary to start a VM with EFI boot and automatically install Harvester.
#
# The command is built progressively by adding each option.
# Note: We use a string variable rather than an array because
# some parameters contain spaces and must be escaped.
# ============================================================================
echo "Step 5: Starting QEMU with EFI boot..."
echo "  This will install Harvester automatically. It may take several minutes..."

# Initialize QEMU command with executable
QEMU_CMD="qemu-system-x86_64"

# VM Configuration
# q35: Modern chipset with better UEFI support than i440fx (legacy)
# accel=kvm: Uses hardware acceleration KVM for better performance
QEMU_CMD="$QEMU_CMD -machine q35,accel=kvm"

# CPU: Use host CPU (passes all features)
# Allows using modern CPU extensions (AVX, AES-NI, etc.)
QEMU_CMD="$QEMU_CMD -cpu host"

# SMP Configuration (Symmetric Multi-Processing)
# cores=2: 2 CPU cores
# threads=2: 2 threads per core (hyperthreading)
# sockets=1: 1 CPU socket
# Total: 4 virtual vCPUs
QEMU_CMD="$QEMU_CMD -smp cores=2,threads=2,sockets=1"

# Memory: 8GB RAM allocated to VM
# Sufficient for installation and operation of Harvester
QEMU_CMD="$QEMU_CMD -m 8192"

# Non-graphical mode: No GUI, output to console
# Useful for automation and environments without X11
QEMU_CMD="$QEMU_CMD -nographic"

# Main serial console: Redirected to stdout/stderr
# Allows seeing kernel and system messages in real-time
QEMU_CMD="$QEMU_CMD -serial mon:stdio"

# Secondary serial console: Redirected to log file
# Captures all installation logs for later analysis
QEMU_CMD="$QEMU_CMD -serial file:harvester-installer.log"

# No network card: Automatic installation doesn't need it
# All necessary images are already in the ISO
QEMU_CMD="$QEMU_CMD -nic none"

# ========================================================================
# Adding UEFI Firmware (OVMF)
# ========================================================================
# Method 1 (recommended): Using pflash with separate files
# - pflash simulates parallel flash memory used by UEFI
# - CODE (readonly): Main UEFI firmware, non-modifiable
# - VARS (read-write): NVRAM variables modifiable by the system
if [ "$USE_SEPARATE_VARS" = true ]; then
  # First pflash: CODE firmware read-only
  # readonly=on: Protects firmware against accidental modifications
  QEMU_CMD="$QEMU_CMD -drive if=pflash,format=raw,readonly=on,file=${OVMF_CODE}"
  
  # Second pflash: NVRAM variables read-write
  # Uses temporary file created in step 4
  QEMU_CMD="$QEMU_CMD -drive if=pflash,format=raw,file=${TEMP_OVMF_VARS}"

# Method 2 (fallback): Using -bios with combined file
# Less flexible but works if separate files are not available
else
  QEMU_CMD="$QEMU_CMD -bios ${OVMF_CODE}"
fi

# ========================================================================
# Storage and Boot Device Configuration
# ========================================================================
# Virtual disk: Raw image created previously
# if=virtio: Virtio interface (better performance than IDE/SATA)
# cache=writeback: Write cache (improves performance)
# discard=ignore: Ignores TRIM commands (not necessary for raw)
QEMU_CMD="$QEMU_CMD -drive file=${RAW_FILE},if=virtio,cache=writeback,discard=ignore,format=raw"

# CD-ROM: Harvester ISO for installation
# Contains live system and all necessary container images
QEMU_CMD="$QEMU_CMD -cdrom ${ISO_FILE}"

# Linux Kernel: vmlinuz file to boot live system
# Extracted from ISO, used for initial boot
QEMU_CMD="$QEMU_CMD -kernel ${KERNEL_FILE}"

# Kernel Parameters: Complete configuration for booting from ISO
# cdroot root=live:CDLABEL=COS_LIVE: Boot from live system on CD
# rd.live.dir=/: Root directory of live system
# rd.live.ram=1: Loads complete system into RAM (faster)
# rd.live.squashimg=rootfs.squashfs: Squashfs image of filesystem
# console=ttyS1: Serial console on ttyS1 (to capture logs)
# rd.cos.disable: Disables some COS features not needed
# net.ifnames=1: Uses predictable network interface names (eth0, etc.)
# harvester.install.mode=install: Install mode (not live mode)
# harvester.install.device=/dev/vda: Target disk for installation (/dev/vda = first virtio disk)
# harvester.install.automatic=true: Automatic installation without interaction
# harvester.install.powerOff=true: Automatically stops VM after successful installation
# harvester.os.password=rancher: Default password for user
# harvester.scheme_version=1: Partitioning scheme version to use
# harvester.install.persistentPartitionSize=150Gi: Persistent partition size (user data)
# harvester.install.skipchecks=true: Skips pre-installation checks (useful for testing)
QEMU_CMD="$QEMU_CMD -append \"cdroot root=live:CDLABEL=COS_LIVE rd.live.dir=/ rd.live.ram=1 rd.live.squashimg=rootfs.squashfs console=ttyS1 rd.cos.disable net.ifnames=1 harvester.install.mode=install harvester.install.device=/dev/vda harvester.install.automatic=true harvester.install.powerOff=true harvester.os.password=rancher harvester.scheme_version=1 harvester.install.persistentPartitionSize=150Gi harvester.install.skipchecks=true\""

# Initrd: Initial ramdisk for boot
# Contains kernel modules and scripts necessary for startup
QEMU_CMD="$QEMU_CMD -initrd ${INITRD_FILE}"

# Boot: Boot from CD once then disk
# once=d: Boot from CD (d) once, then use default order
# After installation, system will boot from disk (/dev/vda)
QEMU_CMD="$QEMU_CMD -boot once=d"

# Execute QEMU with all configured parameters
# eval is necessary because QEMU_CMD contains spaces and quotes
# Installation will happen automatically and VM will stop at the end
eval $QEMU_CMD

# ============================================================================
# Step 6: Displaying Installation Logs
# ============================================================================
# Display the last 100 lines of installation log to verify
# everything went well. Useful for debugging if there's a problem.
# ============================================================================
echo ""
echo "Step 6: Installation log (last 100 lines):"
echo "=========================================="
# || true: Continue even if tail fails (empty or non-existent file)
tail -100 harvester-installer.log || true

# ============================================================================
# Step 7: Verifying Installation
# ============================================================================
# Basic checks to ensure installation succeeded:
# 1. Raw file still exists
# 2. File is not empty (size > 0)
# 3. Partition table can be read (optional check)
# ============================================================================
if [ ! -f "$RAW_FILE" ]; then
  echo "ERROR: Raw image file not found after installation"
  exit 1
fi

# Check file size
# stat -f%z: macOS/BSD (size in bytes)
# stat -c%s: Linux (size in bytes)
# File must have size > 0 (at least some sectors written)
FILE_SIZE=$(stat -f%z "$RAW_FILE" 2>/dev/null || stat -c%s "$RAW_FILE" 2>/dev/null)
if [ "$FILE_SIZE" -eq 0 ]; then
  echo "ERROR: Raw image file is empty"
  exit 1
fi

# Display partition table for verification
# Allows seeing created partitions (EFI, OEM, Recovery, State, etc.)
# || echo: Continue even if parted fails (may need root)
echo ""
echo "Step 7: Verifying partition table..."
parted "$RAW_FILE" print || echo "Warning: Could not read partition table (may need root access)"

# ============================================================================
# Step 8: Compressing Raw Image
# ============================================================================
# Compress raw image with zstd to reduce its size.
# 250GB raw images can be compressed to ~7-10% of their original
# size because they contain many empty spaces (sparse file).
#
# zstd: Modern compression algorithm, fast and efficient
# -T4: Uses 4 threads for compression (parallelization)
# --rm: Removes original file after successful compression
# Result: Much smaller .zst file, easy to transfer
# ============================================================================
echo ""
echo "Step 8: Compressing raw image..."
COMPRESSED_FILE="${RAW_FILE}.zst"

# Remove old compressed file if it exists
# (in case we rerun the script)
if [ -f "$COMPRESSED_FILE" ]; then
  rm -f "$COMPRESSED_FILE"
fi

# Compress with zstd
# Original file will be automatically removed after successful compression
zstd -T4 --rm "$RAW_FILE"
echo "  Created: $COMPRESSED_FILE"

# ============================================================================
# Step 9: Summary and Instructions
# ============================================================================
# Display a summary of the creation and instructions for using
# the created image. Also includes commands to verify EFI boot.
# ============================================================================
echo ""
echo "=========================================="
echo "Build completed successfully!"
echo "=========================================="
echo "Compressed raw image: $COMPRESSED_FILE"
echo ""
echo "To verify EFI boot was used, check for EFI partition:"
echo "  sudo parted $COMPRESSED_FILE print"
echo ""
echo "Note: The raw image has been compressed and removed."
echo "      To decompress: zstd -d $COMPRESSED_FILE"
